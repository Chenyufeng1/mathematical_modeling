clear
global DD %path 为路径，pn为并行方案
load data
load data_you
m=max(size(D));
  temp=zeros(m+2);
  temp(1:m,1:m)=D;
 for i=1:2
   temp(m+i,:)=[D(1,:),ones(1,2)*9999];
   temp(m+i,1)=9999;
   temp(:,m+i)=temp(m+i,:)';
 end
 D=temp;
 temp=0;
[m,pn]=size(D);   %m.pn不能更改
Distance=inf*ones(10000,1);
TracePath=inf*ones(1000,m);
path=zeros(pn,m);
for i=1:pn
    path(i,:)=[1,randperm(m-1)+1];%构造一个初始可行解
end
	path(1,:)=[1	10	17	4	3	6	18	13	14	2	16	15	19	5	7	8	12	9	11	 ];
                     %引导解
 t=zeros(1,pn);    %极小阀值
R=rand(1,pn);     %概率阀值
%p2=zeros(1,m);

iter_max=256;%input('请输入固定温度下最大迭代次数iter_max=' );
m_max=16;%input('请输入固定温度下目标函数值允许的最大连续未改进次数m_nax=' ) ;
%如果考虑到降温初期新解被吸收概率较大，容易陷入局部最优
%而随着降温的进行新解被吸收的概率逐渐减少，又难以跳出局限
%人为的使初期 iter_max,m_max 较小，然后使之随温度降低而逐步增大,可能
%会收到到比较好的效果

tuo=0.9;                %温度下降梯度
T=9999%sum(max(D));          %初始温度
tau=0.1;%input('请输入最低温度tau=' );
N=1;         
        for i=1:pn
               temp_m=0;j=0;k=0;temp=0;p=0;
                 temp_m=find(path(i,:)>m-2);
                 temp_m=[1 temp_m m+1];p=[path(i,:) 1];
           if all((temp_m(2:4)-temp_m(1:3))>1) & ...
                (dis(p(temp_m(1):temp_m(2))) & dis(p(temp_m(2):temp_m(3))) & ...
                    dis(p(temp_m(3):temp_m(4))))
                 temp=zeros(m,1);
               for j=1:3
                  if(fun(p(temp_m(j)+1:temp_m(j+1)-1)-1))
                     temp(temp_m(j))=sum(DD(p(temp_m(j)+1:temp_m(j+1)-1)-1,1));  
                    for k=1 :(temp_m(j+1)-temp_m(j)-1)
                     temp(temp_m(j)+k)=temp(temp_m(j)+k-1)...
                          -DD(p(temp_m(j)+k)-1,1)+DD(p(temp_m(j)+k)-1,2);
                    end
                  else
                     temp=zeros(m,1);;%sum([D(path(i,1:m-1)+m*(path(i,2:m)-1)) D(path(i,m)+m*(path(i,1)-1))])+99999;
                      break 
                  end
                end
                if abs(sum(temp))>0.00001
                  Len1(i)=[D(path(i,1:m-1)+m*(path(i,2:m)-1)) D(path(i,m)+m*(path(i,1)-1))]*((65-temp)/65*2);
                else
                  Len1(i)=9999;
                end
             else
               Len1(i)=9999;
             end
                  %计算一次行遍所有城市的总路程 
        end
           path2=path;Len2=Len1;
while  T>=tau %&m_num<m_max          
       iter_num=1;%某固定温度下迭代计数器
       m_num=1;%某固定温度下目标函数值连续未改进次数计算器    
       while m_num<m_max & iter_num<iter_max
             %用任意启发式算法在path的领域N(path)中找出新的更优解
          for i=1:pn
             [path2(i,: )]=[1,ChangePath2(path(i,2:m ),m-1)];%更新路线
              temp_m=0;p=0;temp=0;j=0;k=0;          %筛选因子
              temp_m=find(path2(i,:)>m-2);
                 temp_m=[1 temp_m m+1];p=[path2(i,:) 1];
             if all((temp_m(2:4)-temp_m(1:3))>1) & ...
                (dis(p(temp_m(1):temp_m(2))) & dis(p(temp_m(2):temp_m(3))) & ...
                     dis(p(temp_m(3):temp_m(4))))
                 temp=zeros(m,1);
               for j=1:3
                  if(fun(p(temp_m(j)+1:temp_m(j+1)-1)-1))
                     temp(temp_m(j))=sum(DD(p(temp_m(j)+1:temp_m(j+1)-1)-1,1));  
                    for k=1 :(temp_m(j+1)-temp_m(j)-1)
                     temp(temp_m(j)+k)=temp(temp_m(j)+k-1)...
                          -DD(p(temp_m(j)+k)-1,1)+DD(p(temp_m(j)+k)-1,2);
                    end
                  else
                     temp=0;;%sum([D(path(i,1:m-1)+m*(path(i,2:m)-1)) D(path(i,m)+m*(path(i,1)-1))])+99999;
                      break 
                  end
               end
                if abs(sum(temp))>0.00001
                  Len2(i)=[D(path2(i,1:m-1)+m*(path2(i,2:m)-1)) D(path2(i,m)+m*(path2(i,1)-1))]*((65-temp)/65*2);
                else
                  Len2(i)=9999;
                end
             else
               Len2(i)=9999;
             end
                  %计算一次行遍所有城市的总路程 
             end
             
            %temp=find((Len2-Len1<t|(exp((Len1-Len2)/T)>R & (Len1-Len2)>t) | (rand(1,m)>0.372))~=0);
             temp=find((Len2-Len1<t|(exp((Len1-Len2)/T)>R ))~=0);
                    %目标值不变时随机变异
            %temp=find((Len2-Len1<t|exp((Len1-Len2)/(T))>R|(Len1-Len2)/(T)<88)~=0);
             if temp
                 path(temp, : )=path2(temp, : );
                 Len1(temp)=Len2(temp);
                 [TempMinD,TempIndex]=min(Len1);
                 TracePath(N,: )=path(TempIndex,: );%记录路径
                 Distance(N,: )=TempMinD;           %记录最小路径值
                 N=N+1;
                 m_num=0;
             else
                 m_num=m_num+1;
             end
             iter_num=iter_num+1;
       end
         min(Distance)
       T=T*tuo
end 
save data_1 TracePath  Distance
clear
